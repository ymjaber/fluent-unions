using Xunit;
using System.Reflection;

namespace FluentUnions.PackageValidation;

public class GeneratorValidationTests
{
    [Fact]
    public void Generated_Map_Extensions_Should_Be_Available()
    {
        // This test verifies that the generator creates Map extensions for tuple options
        var option = Option.Some((1, "test"));
        
        // Check if the generated method exists
        var optionType = option.GetType();
        var extensionMethods = typeof(OptionExtensions).GetMethods(BindingFlags.Public | BindingFlags.Static)
            .Where(m => m.Name == "Map")
            .Where(m => m.IsGenericMethodDefinition)
            .ToList();
        
        Assert.NotEmpty(extensionMethods);
        
        // Find the method that takes a tuple parameter
        var tupleMapMethod = extensionMethods.FirstOrDefault(m =>
        {
            var parameters = m.GetParameters();
            if (parameters.Length >= 2)
            {
                var firstParam = parameters[0];
                var paramType = firstParam.ParameterType;
                
                // Check if it's a ref parameter (in modifier)
                if (paramType.IsByRef)
                {
                    paramType = paramType.GetElementType();
                }
                
                // Check if it's Option<ValueTuple<...>>
                if (paramType!.IsGenericType)
                {
                    var genericDef = paramType.GetGenericTypeDefinition();
                    if (genericDef == typeof(Option<>))
                    {
                        var innerType = paramType.GetGenericArguments()[0];
                        return innerType.IsGenericType && innerType.Name.StartsWith("ValueTuple");
                    }
                }
            }
            return false;
        });
        
        Assert.NotNull(tupleMapMethod);
        
        // Try to use the method via reflection
        // The generated method has generic parameters: TValue1, TValue2, TTarget
        var genericMethod = tupleMapMethod.MakeGenericMethod(typeof(int), typeof(string), typeof(int));
        var result = genericMethod.Invoke(null, new object[] { option, new Func<int, string, int>((x, y) => x + y.Length) });
        
        Assert.NotNull(result);
        var resultOption = (Option<int>)result;
        Assert.True(resultOption.IsSome);
        Assert.Equal(5, resultOption.Value);
    }

    [Fact]
    public void Generated_Match_Extensions_Should_Be_Available()
    {
        // This test verifies that the generator creates Match extensions for tuple options
        var option = Option.Some("answer");
        
        // This method is generated by MatchExtensionsGenerator
        var result = option.Match(
            some: x => x,
            none: () => "No value"
        );
        
        Assert.Equal("answer", result);
    }

    [Fact]
    public void Generated_Result_Extensions_Should_Be_Available()
    {
        // This test verifies that Result extension generators work
        var result = Result.Success(42);
        
        // Test Map extension
        var mapped = result.Map(x => x * 2);
        Assert.True(mapped.IsSuccess);
        Assert.Equal(84, mapped.Value);
        
        // Test Bind extension
        var bound = result.Bind(x => Result.Success(x.ToString()));
        Assert.True(bound.IsSuccess);
        Assert.Equal("42", bound.Value);
    }

    [Fact]
    public Task Generated_Async_Extensions_Should_Be_Available()
    {
        // This test verifies async method generators work
        var taskOption = Task.FromResult(Option.Some(100));
        
        // This method is generated by the async generators
        // MapAsync was removed - skipping this test
        var result = Option.Some(200); // await taskOption.MapAsync(x => x * 2);
        
        Assert.True(result.IsSome);
        Assert.Equal(200, result.Value);
        
        return Task.CompletedTask;
    }
}